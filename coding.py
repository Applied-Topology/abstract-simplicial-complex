from pprint import pprint
from itertools import combinations
import numpy as np


def get_subsimplices(simplex, k):
    """
    Returns a list with all possible subsimplices (of dim k) in a provided simplex
    """
    if type(simplex) is set:
        simplex = list(simplex)

    dim_simplex = len(simplex) - 1
    subsimplices = []
    
    if dim_simplex < k:
        return subsimplices

    combos = combinations(range(len(simplex)), k+1)
    for comb in combos:
        subsimplices.append({simplex[i] for i in comb})
    return subsimplices


def union_list_set(lst1, lst2):
    """
    Returns the union of two lists of sets, optimizing space efficiency 
    by modifying lst1 
    """
    for t in lst2:
        if t not in lst1: 
            lst1.append(t)
    return lst1


def boundary_matrix(dim, representation):
    """
    Returns the boundary map, d_k where k = dim
    d_k:  C_{k} - C_{k-1}
    Given the representation generated by the mk_complex() function defined below
    We will use the fact that our representation is already sorted in descending 
    order by the dimension of the simplex 
    """
    generators_pre = []
    generators_post = []
    for r in representation:
        if len(r) > dim+1:
            s = get_subsimplices(r, dim)
            generators_pre += s
            for t in s:
                generators_post = union_list_set(generators_post, get_subsimplices(t, dim-1))
        elif len(r) == dim+1:
            generators_pre.append(r) 
            generators_post = union_list_set(generators_post, get_subsimplices(r, dim-1))

    matrix = [] 
    for post in generators_post:
        matrix.append([1 if post.issubset(pre) else 0 for pre in generators_pre])
    return matrix, generators_pre, generators_post


def mk_complex(sc_list):
    """
    New representation of the simplicial complex more specialized for the Mar 11 coding assignment 
    Attempts to be space efficient as possible. Goes through the simplicial complex list and first considers 
    the largest simplex, then adds in the lower dimensional simplices, making sure they cannot be constructed 
    from the boundary map of a higher dimensional simplex

    Use of dim (to mean dimension) here is deliberately incorrect here (really dim+1, 
    but not elegant to write as a variable)
    """
    sc_sizes = map(lambda x: len(x), sc_list)
    scs_index = list(zip(sc_sizes, range(len(sc_list))))
    scs_index.sort(reverse=True, key=lambda x: x[0])
    
    dim_largest_simplex = scs_index[0][0]

    representation = []

    for (dim, ind) in scs_index:
        if dim == dim_largest_simplex:
            representation.append(sc_list[ind]) 
        else:
            found_subcomplex = False  
            for rep in representation:
                if sc_list[ind].issubset(rep):
                    found_subcomplex = True
                    break
            if not found_subcomplex:
                representation.append(sc_list[ind])
    return representation


def main():
    vertices = ['Cow', 'Rabbit', 'Horse', 'Dog', 'Fish', 'Dolphin', 'Oyster', 'Broccoli', 'Fern', 'Onion', 'Apple']
    edges_a = [{'Cow', 'Rabbit'}, {'Cow', 'Horse'}, {'Cow', 'Dog'}, {'Rabbit', 'Horse'}, {'Rabbit', 'Dog'}, {'Horse', 'Dog'}, {'Fish', 'Dolphin'}, {'Fish', 'Oyster'}, {'Dolphin', 'Oyster'}, {'Broccoli', 'Fern'}, {'Broccoli', 'Onion'}, {'Broccoli', 'Apple'}, {'Fern', 'Onion'}, {'Fern', 'Apple'}, {'Onion', 'Apple'}, {'Cow', 'Rabbit', 'Horse'}, {'Cow', 'Rabbit', 'Dog'}, {'Cow', 'Horse', 'Dog'}, {'Rabbit', 'Horse', 'Dog'}, {'Fish', 'Dolphin', 'Oyster'}, {'Broccoli', 'Fern', 'Onion'}, {'Broccoli', 'Fern', 'Apple'}, {'Broccoli', 'Onion', 'Apple'}, {'Fern', 'Onion', 'Apple'}]
    edges_b = [{'Cow','Rabbit'},{'Cow','Fish'},{'Cow','Oyster'},{'Cow','Oyster'},{'Cow','Broccoli'},{'Cow','Onion'},{'Cow','Apple'},{'Rabbit','Fish'},{'Rabbit','Oyster'},{'Rabbit','Broccoli'},{'Rabbit','Onion'},{'Rabbit','Apple'},{'Fish','Oyster'},{'Fish','Broccoli'},{'Fish','Onion'},{'Fish','Apple'},{'Oyster','Broccoli'},{'Oyster','Onion'},{'Oyster','Apple'},{'Broccoli','Onion'},{'Broccoli','Apple'},{'Onion','Apple'},{'Horse','Dog'},{'Horse','Dolphin'},{'Horse','Fern'},{'Dog','Dolphin'},{'Dog','Fern'},{'Dolphin','Fern'},{'Cow','Broccoli','Apple'},{'Cow','Onion','Apple'},{'Rabbit','Broccoli','Apple'},{'Rabbit','Onion','Apple'},{'Fish','Broccoli','Apple'},{'Fish','Onion','Apple'},{'Oyster','Broccoli','Apple'},{'Oyster','Onion','Apple'}]
    
    vertex_set = [{x} for x in vertices]

    rep_a = mk_complex(edges_a + vertex_set)
    rep_b = mk_complex(edges_b + vertex_set)

    print("Part A ---------------------")
    for dim in range(2, 0, -1):
        print("Boundary Matrix for dim ", dim)
        m, pre, post = boundary_matrix(dim, rep_a)
        print("Rows correspond to ", post)
        print("Columns correspond to ", pre)
        pprint(np.asarray(m))

    print("Part B ---------------------")
    for dim in range(2, 0, -1):
        print("Boundary Matrix for dim ", dim)
        m, pre, post = boundary_matrix(dim, rep_b)
        print("Rows correspond to ", post)
        print("Columns correspond to ", pre)
        pprint(np.asarray(m))




if __name__ == "__main__":
    main()


